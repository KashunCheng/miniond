//! Mount operations.

use std::path::PathBuf;

use libsystemd::unit::escape_name;
use tokio::fs::{OpenOptions, create_dir_all};
use tokio::process::Command;
use tokio::io::AsyncWriteExt;

use crate::error::{Error, Result};

/// A mount backend.
#[derive(Debug, Clone)]
pub enum Backend {
    /// Use systemd to handle mounting.
    ///
    /// The path points to the unit file directory
    /// (usually `/etc/systemd/system`).
    Systemd(PathBuf),
}

/// An NFS mount.
#[derive(Debug, Clone)]
pub struct NfsMount {
    remote: String,
    local: PathBuf,
}

impl NfsMount {
    pub fn new(remote: String, local: PathBuf) -> Self {
        Self {
            remote,
            local,
        }
    }

    /// Apply the configuration on the host.
    pub async fn apply(&self, backend: Backend) -> Result<()> {
        match backend {
            Backend::Systemd(unit_dir) => {
                // Create systemd mount unit
                let unit_name = {
                    let unescaped = self.local.strip_prefix("/").unwrap();
                    format!("{}.mount", escape_name(unescaped.to_str().unwrap()))
                };

                log::info!("Creating systemd unit {} for {}...", unit_name, self.remote);

                // This directory may not exist yet.
                create_dir_all(&unit_dir).await?;

                let unit_path = unit_dir.join(&unit_name);
                let mut file = OpenOptions::new()
                    .read(false)
                    .write(true)
                    .create(true)
                    .truncate(true)
                    .open(&unit_path)
                    .await?;

                file.write_all("# This mount unit was automatically generated by miniond\n\n".as_bytes()).await?;
                file.write_all("[Mount]\n".as_bytes()).await?;
                file.write_all(format!("What={}\n", self.remote).as_bytes()).await?;
                file.write_all(format!("Where={:?}\n", self.local).as_bytes()).await?;
                file.write_all("Type=nfs\n".as_bytes()).await?;
                file.write_all("TimeoutSec=30s\n".as_bytes()).await?;

                // Start the mount
                let status = Command::new("systemctl")
                    .arg("daemon-reload")
                    .status()
                    .await?;

                if !status.success() {
                    return Err(Error::Mount);
                }

                let status = Command::new("systemctl")
                    .args(&["start", &unit_name])
                    .status()
                    .await?;

                if !status.success() {
                    return Err(Error::Mount);
                }

                Ok(())
            }
        }
    }
}
